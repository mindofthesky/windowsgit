# -*- coding: utf-8 -*-
"""
Created on Mon Mar 11 04:59:37 2024

@author: mindo
"""
ingredient = [2, 1, 1, 2, 3, 1, 2, 3, 1]	
# result = 2 

# 햄버거 가게에서 일을 하는 상수는 햄버거를 포장하는 일을 합니다. 함께 일을 하는 다른 직원들이 햄버거에 들어갈 재료를 조리해
# 주면 조리된 순서대로 상수의 앞에 아래서부터 위로 쌓이게 되고, 상수는 순서에 맞게 쌓여서 완성된 햄버거를 따로 옮겨 포장을 하게 됩니다. 
# 상수가 일하는 가게는 정해진 순서(아래서부터, 빵 – 야채 – 고기 - 빵)로 쌓인 햄버거만 포장을 합니다. 상수는 손이 굉장히 빠르기 
# 때문에 상수가 포장하는 동안 속 재료가 추가적으로 들어오는 일은 없으며, 
# 재료의 높이는 무시하여 재료가 높이 쌓여서 일이 힘들어지는 경우는 없습니다.

# 예를 들어, 상수의 앞에 쌓이는 재료의 순서가 [야채, 빵, 빵, 야채, 고기, 빵, 야채, 고기, 빵]일 때, 
# 상수는 여섯 번째 재료가 쌓였을 때, 세 번째 재료부터 여섯 번째 재료를 이용하여 햄버거를 포장하고, 
# 아홉 번째 재료가 쌓였을 때, 두 번째 재료와 일곱 번째 재료부터 아홉 번째 재료를 이용하여 햄버거를 포장합니다.
# 즉, 2개의 햄버거를 포장하게 됩니다.
# 상수에게 전해지는 재료의 정보를 나타내는 정수 배열 ingredient가 주어졌을 때, 상수가 포장하는 햄버거의 개수를 return 하도록 solution 함수를 완성하시오.

# [빵 , 야채, 고기, 빵] > 순서대로 데이터가 저장이됨 
# [2, 1, 1, 2, 3, 1, 2, 3, 1] 가 값이고
# dict  1 빵, 2 야채, 3 고기 
# 3 ~ 6    부터 1개 
# 2, 7 ~ 9 부터 2개  
# 1 2 3 1 +=1
# 1 2 3 1 +=1 
# 연속한 1, 1 로는 할수없다
# 2로 시작을 할수없다 
# 첫번째는 

# ing[i] == 1인지부터확인
# ing[0] = 2 이기때문에 시작불가 
# ing[1] == ing[2] 같은 1이니 실행x
def solution(ingredient):
    answer = 0
    i = 0 
    while i < len(ingredient)-3:
        if ingredient[i] == 1:
            if ingredient[i:i+4] == [1,2,3,1]:
                del ingredient[i:i+4]
                # ingredient[i:i+4] == 0 > 무한루프 > 이걸로할거면 아에 스택식으로 만들어야함 
                i = i - 3
                answer +=1
                continue
        i +=1
            # 첫번째값이 있으면
            # 2 3 1 배열을 찾아내야함 
            # 순서는 무조건 2 3 1 순서 
            # 2, 1, 1, 2, 3, 1, 2, 3, 1
            # 첫번째를 시행하고나면
            # 2, 1, 0, 0, 0, 0, 2, 3, 1
            # 이제 남은것으로 볼수있음 
            # 0으로 바꾸게되면 다음값이 같으니까 볼필요가 없고 >> 이걸 처리했더니 무한 루프걸림 
            # del로 삭제처리해야됨 
            # 2, 3, 1 연속되는지도 보기가 쉽다 
        
    print(answer)        
    return answer

solution(ingredient)