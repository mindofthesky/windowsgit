# -*- coding: utf-8 -*-
"""
Created on Thu Apr  4 20:39:21 2024

@author: mindo
"""

n = 2
l = 4
r = 17
# result = 8 
def solution(n, l, r):
    answer = 0
    # 칸토어 집합은 0,1 의 사이의 실수로 집합이며 
    # [0,1] 부터 시작하여 각 구간을 3등분하여 반복적으로 제외하면서 만든다
    # 사용자는 칸토어 배열을 변형해서 유사 칸토어 배열을 만들었음
    # 0 번째 유사 칸토어배열은 1이고
    # n 번째로 유사 칸토어 비트열을 n-1 번째 유사 비트열에서 11011 로 치환하고 
    # 0은 00000 으로 변경함 
    # n번째 유사칸토어 배열에서 특정구간에서 1의 갯수를 알고싶음 
    # l,r 구간에서 1의 갯수를 알아오는 코드를 작성해라 
    # 2 번째 유사 칸토어 비트열은 "1101111011000001101111011" 입니다. 
    # 음영 표시된 부분은 폐구간 [4, 17] 이며 구간 내의 1은 8개 있습니다.
    # 0 -> 1 
    # 1 -> 11011
    # 2 -> 1101111011000001101111011
    # 재귀형문제 ? 
    
    # 아 갯수는 정해짐 
    # 왜냐면 비트수는 정해져있지만
    # 숫자는 계속반복이기때문에 
    # 5개로 나눠서보면 5배가 되는 개념 
    def is_one(l):
        while l >= 5:
            if(l -2 ) % 5 == 0:
                return False
            l //= 5
        return l != 2
    for l in range(l-1 , r):
        if is_one(l):
            print(is_one(l))
            answer +=1
    print(answer)
    # true가 되면 1이 추가 아닌경우는 0을 내뱉을테니까 
    return answer 
    
solution(n, l, r)