using DnfTcg.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;
using System.Windows;

namespace dnf_tcg.models
{
    public class SkillCard : Card
    {
        // Skill progression
        public int Level { get; set; } = 0; // current mastery level
        public int MaxLevel { get; set; } = 999;
        public int LevelStep { get; set; } = 10; // how much level increases per use
        public int InitialLevel { get; set; } = 0; // starting mastery

        public int CubeCost { get; set; } = 0;
        public Action<Player, Player, int> Effect { get; set; }

        public int Damage { get; set; }

        // Track when this skill was placed on the field so it doesn't trigger same turn
        public int TurnPlaced { get; set; } = 0;

        public SkillCard(string name, int levelReq, int cubeCost, Action<Player, Player, int> effect)
        {
            Name = name;
            LevelRequirement = levelReq;
            CubeCost = cubeCost;
            Effect = effect;
            Type = CardType.Skill;
            Level = InitialLevel;
            LevelStep = 10;
        }

        // overload to set initial level and step
        public SkillCard(string name, int levelReq, int cubeCost, int initialLevel, int levelStep, Action<Player, Player, int> effect)
        {
            Name = name;
            LevelRequirement = levelReq;
            CubeCost = cubeCost;
            Effect = effect;
            Type = CardType.Skill;
            InitialLevel = initialLevel;
            Level = InitialLevel;
            LevelStep = levelStep;
        }

        // legacy constructor (no cube cost)
        public SkillCard(string name, int levelReq, Action<Player, Player, int> effect)
            : this(name, levelReq, 0, effect)
        {
        }

        public override void Play(Player self, Player enemy)
        {
            var currentTurn = GameManager.Instance?.TurnNumber ?? 0;

            // Never allow using skills on the first turn
            if (currentTurn < 2)
            {
                MessageBox.Show("첫 턴에는 스킬을 사용할 수 없습니다.", "알림", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            // Prevent usage on same turn placed
            if (TurnPlaced == currentTurn)
            {
                MessageBox.Show($"{Name} was just placed and cannot be used this turn.", "알림", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            if (self.CubeShards < CubeCost)
            {
                MessageBox.Show($"{self.Name} does not have enough Cube Shards to use {Name}.", "알림", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            // pay cost
            self.CubeShards -= CubeCost;

            // increase mastery level in player's skillbook
            if (self.Skills.ContainsKey(Name))
            {
                self.Skills[Name].Level = Math.Min(self.Skills[Name].Level + self.Skills[Name].LevelStep, self.Skills[Name].MaxLevel);
            }
            else
            {
                // register this skill instance as learned
                if (this.Level == 0) this.Level = InitialLevel;
                self.Skills[Name] = this;
            }

            var usedLevel = self.Skills[Name].Level;

            // execute effect using learned level
            Effect(self, enemy, usedLevel);
            Console.WriteLine($"{self.Name} used {Name} (Lv {usedLevel}) and spent {CubeCost} Cube Shards.");

            // After use, move this card to graveyard (if not already moved)
            if (!self.Graveyard.Contains(this))
            {
                // remove from any field slot
                if (self.Field.Skill1 == this) self.Field.Skill1 = null;
                if (self.Field.Skill2 == this) self.Field.Skill2 = null;
                if (self.Field.Skill3 == this) self.Field.Skill3 = null;

                self.Graveyard.Add(this);
            }
        }
    }
}
